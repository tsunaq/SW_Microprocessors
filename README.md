# SW_Microprocessors

## tPU ISA(Instruction Set Architecture)

![1](https://user-images.githubusercontent.com/58457978/70217561-be0f0a00-1784-11ea-8809-467abfc85954.png)
![2](https://user-images.githubusercontent.com/58457978/70217560-be0f0a00-1784-11ea-9f19-ebe66fb6c0c5.png)

## 과제1) 아래 행렬에 대해서 TPU 프로세스를 이용하여 행렬 곱 계산을 수행한다.

![image](https://user-images.githubusercontent.com/58457978/70216650-51dfd680-1783-11ea-9dfe-588fcb1de088.png)

– 요구사항  
최종 결과 C행렬은 메모리에 저장되어야 함  
A행렬과 B행렬 값도 아래의 값을 그대로 유지하여 메모리에 존재해야 한다.  

### 알고리즘
![3](https://user-images.githubusercontent.com/58457978/70217689-01697880-1785-11ea-8d77-f66834f8478c.png)

### 어셈블리어 구현


1. A 행렬 메모리 저장  
MOV3 R0, 1  
MOV3 R1, 2  
MOV3 R2, 3  
MOV3 R3, 4  
MOV3 R4, 5  
MOV3 R5, 6  
MOV3 R6, 7  
MOV3 R7, 8  
MOV3 R8, 9  
MOV1 [0], R0  
MOV1 [1], R1  
MOV1 [2], R2  
MOV1 [3], R3  
MOV1 [4], R4  
MOV1 [5], R5  
MOV1 [6], R6  
MOV1 [7], R7  
MOV1 [8], R8  

2. B 행렬 메모리 저장
MOV3 R0, 10  
MOV3 R1, 11  
MOV3 R2, 12  
MOV3 R3, 13  
MOV3 R4, 14  
MOV3 R5, 15  
MOV3 R6, 16  
MOV3 R7, 17  
MOV3 R8, 18  
MOV1 [9], R0  
MOV1 [10], R1  
MOV1 [11], R2  
MOV1 [12], R3  
MOV1 [13], R4  
MOV1 [14], R5  
MOV1 [15], R6  
MOV1 [16], R7  
MOV1 [17], R8  

3. C0 계산 및 메모리 저장  
MOV0 R0, [0]   
MOV0 R1, [1]  
MOV0 R2, [2]  
MOV0 R3, [9]  
MOV0 R4, [12]  
MOV0 R5, [15]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [18], R0  

4. C1 계산 및 메모리 저장  
MOV0 R0, [0]  
MOV0 R1, [1]  
MOV0 R2, [2]  
MOV0 R3, [10]  
MOV0 R4, [13]  
MOV0 R5, [16]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [19], R0  

5. C2 계산 및 메모리 저장  
MOV0 R0, [0]  
MOV0 R1, [1]  
MOV0 R2, [2]  
MOV0 R3, [11]  
MOV0 R4, [14]  
MOV0 R5, [17]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [20], R0  

6. C3 계산 및 메모리 저장  
MOV0 R0, [3]  
MOV0 R1, [4]  
MOV0 R2, [5]  
MOV0 R3, [9]  
MOV0 R4, [12]  
MOV0 R5, [15]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [21], R0  

7. C4 계산 및 메모리 저장  
MOV0 R0, [3]  
MOV0 R1, [4]  
MOV0 R2, [5]  
MOV0 R3, [10]  
MOV0 R4, [13]  
MOV0 R5, [16]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [22], R0  

8. C5 계산 및 메모리 저장  
MOV0 R0, [3]  
MOV0 R1, [4]  
MOV0 R2, [5]  
MOV0 R3, [11]  
MOV0 R4, [14]  
MOV0 R5, [17]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [23], R0  

9. C6 계산 및 메모리 저장  
MOV0 R0, [6]  
MOV0 R1, [7]  
MOV0 R2, [8]  
MOV0 R3, [9]  
MOV0 R4, [12]  
MOV0 R5, [15]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2    
MOV1 [24], R0  

10. C7 계산 및 메모리 저장  
MOV0 R0, [6]  
MOV0 R1, [7]  
MOV0 R2, [8]  
MOV0 R3, [10]  
MOV0 R4, [13]  
MOV0 R5, [16]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [25], R0  

11. C8 계산 및 메모리 저장  
MOV0 R0, [6]  
MOV0 R1, [7]  
MOV0 R2, [8]  
MOV0 R3, [11]  
MOV0 R4, [14]  
MOV0 R5, [17]  
MUL R0, R3  
MUL R1, R4  
MUL R2, R5  
ADD R0, R1  
ADD R0, R2  
MOV1 [26], R0  

### 바이너리 코드 변환
0011000000000001
0011000100000010
0011001000000011
0011001100000100
0011010000000101
0011010100000110
0011011000000111
0011011100001000
0011100000001001
0001000000000000
0001000100000001
0001001000000010
0001001100000011
0001010000000100
0001010100000101
0001011000000110
0001011100000111
0001100000001000
0011000000001010
0011000100001011
0011001000001100
0011001100001101
0011010000001110
0011010100001111
0011011000010000
0011011100010001
0011100000010010
0001000000001001
0001000100001010
0001001000001011
0001001100001100
0001010000001101
0001010100001110
0001011000001111
0001011100010000
0001100000010001
0000000000000000
0000000100000001
0000001000000010
0000001100001001
0000010000001100
0000010100001111
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000010010
0000000000000000
0000000100000001
0000001000000010
0000001100001010
0000010000001101
0000010100010000
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000010011
0000000000000000
0000000100000001
0000001000000010
0000001100001011
0000010000001110
0000010100010001
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000010100
0000000000000011
0000000100000100
0000001000000101
0000001100001001
0000010000001100
0000010100001111
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000010101
0000000000000011
0000000100000100
0000001000000101
0000001100001010
0000010000001101
0000010100010000
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000010110
0000000000000011
0000000100000100
0000001000000101
0000001100001011
0000010000001110
0000010100010001
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000010111
0000000000000110
0000000100000111
0000001000001000
0000001100001001
0000010000001100
0000010100001111
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000011000
0000000000000110
0000000100000111
0000001000001000
0000001100001010
0000010000001101
0000010100010000
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000011001
0000000000000110
0000000100000111
0000001000001000
0000001100001011
0000010000001110
0000010100010001
0111000000110000
0111000101000000
0111001001010000
0100000000010000
0100000000100000
0001000000011010

### 결과
![image](https://user-images.githubusercontent.com/58457978/70218073-ab490500-1785-11ea-8a2f-3ca127c621ff.png)

## 과제2) 주어진 C코드에 대한 TPU 명령어로 표현하여 성능을 측정한다.

![image](https://user-images.githubusercontent.com/58457978/70216958-d92d4a00-1783-11ea-8fa7-cfd78d163ac5.png)

- 요구사항  
MOV4를 사용하지 않은 어셈블리 코드를 작성하고 성능 측정  
MOV4를 사용할 때 성능 측정 비표  

### 알고리즘 구현

① MOV4를 사용하지 않은 어셈블리 코드를 작성하고 성능 측정  
MOV3 R0, #1  
MOV3 R1, #1  
MOV3 R2, #2  
MOV3 R5, #10  
SUB R5, R2  
MOV3 R3, #1  
JZ R5, 9  
MOV3 R6, #0  
ADD R1, R0  
ADD R6, R1  
MOV1 [0], R0  
MOV0 R1, [0]  
MOV1 [0], R6  
MOV0 R0, [0]  
SUB R5, R3  
JZ R4, -10  

② MOV4를 사용할 때 성능 측정 비표  
MOV3 R0, #1  
MOV3 R1, #1  
MOV3 R2, #2  
MOV3 R5, #10  
SUB R5, R2  
MOV3 R3, #1  
JZ R5, 7  
MOV3 R6, #0  
ADD R1, R0  
ADD R6, R1  
MOV4 R1, R0  
MOV4 R0, R6  
SUB R5, R3  
JZ R4, -8  

### 바이너리 코드 변환

① MOV4를 사용하지 않은 어셈블리 코드를 작성하고 성능 측정
0011000000000001
0011000100000001
0011001000000010
0011010100001010
0101010100100000
0011001100000001
0110010100001001
0011011000000000
0100000100000000
0100011000010000
0001000000000000
0000000100000000
0001011000000000
0000000000000000
0101010100110000
0110010011110110

② MOV4를 사용할 때 성능 측정 비표
0011000000000001
0011000100000001
0011001000000010
0011010100001010
0101010100100000
0011001100000001
0110010100000111
0011011000000000
0100000100000000
0100011000010000
1000000100000000
1000000001100000
0101010100110000
0110010011111000

### 결과
![image](https://user-images.githubusercontent.com/58457978/70218014-93718100-1785-11ea-9271-39d939cd9e6d.png)
① MOV4를 사용하지 않은 어셈블리 코드를 작성하고 성능 측정  

![image](https://user-images.githubusercontent.com/58457978/70218022-95d3db00-1785-11ea-9720-b782cc932ef1.png)
② MOV4를 사용할 때 성능 측정 비표

## 과제3) 아래 행렬에 대해서 TPU 프로세스를 이용하여 행렬 곱 계산을 수행한다.

![image](https://user-images.githubusercontent.com/58457978/70217245-1bef2200-1784-11ea-97b2-3086cb6bf850.png)

‒ 요구사항  
최종 결과 C행렬은 메모리에 저장되어야 함  
A행렬과 B행렬 값도 아래의 값을 그대로 유지하여 메모리에 존재해야 한다.  
JZ 명령어를 반드시 사용하여 loop 형태로 프로그램을 작성해야 한다.  
다음 페이지의 TPU 모델 수정을 반드시 해야 한다.  
행렬 곱 연산의 성능을 측정한다.  
성능을 높이기 위한 방법을 제시하고 그로 인한 성능 향상을 보인다.  

### 알고리즘 구현(C++ 이용)
![image](https://user-images.githubusercontent.com/58457978/70287668-23114100-1813-11ea-9a07-ea7e72c9ab61.png)

### 어셈블리어 구현  
MOV3 R0, #50 ; line 1  
MOV3 R1, #1  
MOV3 R2, #1  
JZ R0, 4  
MOV2 R1, R1  
ADD R1, R2  
SUB R0, R2  
JZ R3, -5 ; line 8  
MOV3 R0, #0 ; line 9  
MOV3 R7, #1  
MOV3 R8, #5  
MOV3 R10, #26  
MOV3 R11, #51  
MOV3 R12, #0  
MOV3 R13, #5  
MOV3 R15, #5  
MOV3 R10, #0  
MOV3 R5, #1  
MOV3 R6, #26  
MOV4 R3, R5  
MOV3 R14, #5 ; line 21  
JZ R13, 24 ; line 22  
MOV4 R4, R6  
JZ R14, 18 ; line 24  
MOV4 R9, R3  
MOV4 R10, R4  
JZ R15, 8 ; line 27  
MOV4 R1, R9  
MOV4 R2, R1O  
MUL R1, R2  
ADD R0, R1  
ADD R9, R7  
ADD R10, R8  
SUB R15, R7  
JZ R12, -9 ; line 35  
MOV2 R11, R0  
MOV3 R0, #0  
ADD R11, R7  
MOV3 R15, #5  
ADD R4, R7  
SUB R14, R7  
JZ R12, -19 ; line 42  
MOV3 R14, #5  
ADD R3, R8  
SUB R13, R7  
JZ R12, -25 ; line 46  

### 바이너리 코드 변환
0011000000110010
0011000100000001
0011001000000001
0110000000000100
0010000100000001
0100000100100000
0101000000100000
0110001111111011
0011000000000000
0011011100000001
0011100000000101
0011101000010101
0011101100110011
0011110000000000
0011110100000101
0011111100000101
0011101000000000
0011010100000001
0011011000011010
1000001101010000
0011111000000101
0110110100011000
1000010001100000
0110111000010010
1000100100110000
1000101001000000
0110111100001000
1000000110010000
1000001010100000
0111000100100000
0100000000010000
0100100101110000
0100101010000000
0101111101110000
0110110011110111
0010101100000000
0011000000000000
0100101101110000
0011111100000101
0100010001110000
0101111001110000
0110110011101101
0011111000000101
0100001110000000
0101110101110000
0110110011100111

### 
![image](https://user-images.githubusercontent.com/58457978/70218651-b8b2bf00-1786-11ea-92a4-4c513cc835b4.png)


